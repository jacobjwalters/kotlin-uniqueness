\section{\Lbase}

\Lbase is a simple typed language consisting of sequentially ordered statements with method calls. There are no modes, no classes, and no lambdas (or other methods of capturing).

\subsection{Syntax}
\begin{bnf}
  P ::=
    | $\overline{M}$  : Programs
    ;;
  M ::=
    | $m(\overline{x \Colon \tau}) \Colon \sigma \{ \Begin \Semi s \Semi \Return \, e \}$  : Method Definitions
    | $m(\overline{x \Colon \tau}) \Colon \sigma$  : Method Declarations
    ;;
  $\tau$, $\sigma$ ::=
    | $\Nat$ : Naturals
    | $\Bool$ : Booleans
    ;;
  $e$ ::=
    | $\Null$
    | $x$  : Variable Access
    | $m(\overline{e})$  : Method Call
    | $\True$
    | $\False$
    | $n \in \mathbb{N}$ : Natural Numbers
    ;;
  $s$ ::=
    | $\Var x \Colon \tau$  : (Mutable) Variable Declaration
    | $x = e$  : Variable Assignment/Mutation
    | $s_1 \Semi s_2$  : Statement Sequencing
    | $\If e \Then s_1 \Else s_2$
    | $\Return{} e$  : Early Return
    | $m(\overline{e})$  : Method Call
    ;;
\end{bnf}

Overlined elements denote n-ary lists of such elements. $x$ and $m$ represent infinte sets of variable and method names respectively. Methods are all defined top-level, and may be (mutually) recursive.
\jtodo{Confirm with Komi: do we want (mutual) recursion?}

Non-forgetful differences from the system described by \textcite{protopapa2024VerifyingKotlinCode} are:
\begin{itemize}
\item Our system is typed (and has $\Nat$ and $\Bool$ as ground types)
\item ITE tests an arbitrary boolean expression, rather than direct equality on patterns.
\end{itemize}

For brevity's sake, we define $\Var x : \tau = e$ as $\Var x : \tau \Semi x = e$. Additionally, we assume usual boolean/arithmetic operators are defined as method call expressions.

\subsection{Typing Contexts}
Typing contexts (hereafter contexts) in \Lbase{} are (rightwards-growing) lists of names and their associated types. In particular, we have a (global) list of methods and associated method types\footnote{Since we don't have object-level function types, a method type is a list of argument types, paired with a return type} paired with a list of ``stack frames,'' each of which is a list of variable names and associated types. In this working note, stack frames will be displayed as $\square$ in the context

The grammar for contexts is as follows:

\begin{bnf}
  $\Gamma$ ::=
    | $\cdot$ : Empty
    | $\Gamma, x \Colon \tau$ : Variable Extension
    | $\Gamma, \square$ : Stack Frame Delimiter
    ;;
\end{bnf}

Statements in \Lbase may alter their context, particular for variable declaration and (early) return statements. To model this, we take a small-step semantics like approach to dealing with contexts, with judgements of the form $\Gamma \vdash s \dashv \Gamma'$.

\subsubsection{Well Formed Contexts}
We introduce a judgement $\Gamma \ctx$, to denote well formed contexts (WFCs). WFCs are defined inductively:
\begin{mathpar}
  \ir{CtxEmp}{ }{\cdot \ctx}

  \ir{CtxVarExt}{\Gamma \ctx \\ x \notin \Gamma}{\Gamma, x : \tau \ctx}
\end{mathpar}

$x \notin \Gamma$ is bookkeeping for ensuring all names are distinct, and isn't strictly needed. Membership checking and lookup are defined in the usual way.
\jq{Do we want to allow name reuse (and thus shadowing)? How will this interact with borrowing later on?}

\subsubsection{Removal}
\jc{This part until the next question is likely irrelevant}
We need a removal operator acting on the context, to remove local variables when leaving a scope. We define removal inductively:
\begin{mathpar}
  \ir{RemoveEmp}{ }{\cdot \setminus x = \cdot}

  \ir{RemoveVar}{ }{\Gamma, x : \tau \setminus x = \Gamma}

  \ir{RemoveRec}{\Gamma \setminus x = \Gamma' \\ x \neq y}{\Gamma, y : \tau \setminus x = \Gamma', y : \tau}
\end{mathpar}
\jq{If we want shadowing, how should we deal with removal? With the above approach, we have no way of knowing which variables are declared in the local scope, and which are needed outside of the scope. My gut feeling is that we need a notion of stack frame in the context.}

\subsection{Type System}
Typing expressions is straightforward. We use the standard $\Gamma \vdash e : \tau$ judgement form.

\jtodo{Expression types}

Typing statements is more involved. Since statments may update their context, we use a ``small-step'' typing judgement form $\Gamma \vdash s \dashv \Gamma'$, where $\Gamma$ represents the context before the statement runs, and $\Gamma'$ represents the context after the statement runs.

\begin{mathpar}
  \ir{VarDecl}{x \notin \Gamma}{\Gamma \vdash \Var x : \tau \dashv \Gamma, x : \tau}

  \ir{VarAssign}{\Gamma, x : \tau \vdash e : \tau}{\Gamma, x : \tau \vdash x = e \dashv \Gamma, x : \tau}

  \ir{Seq}{\Gamma \vdash s_1 \dashv \Gamma' \\ \Gamma' \vdash s_2 \dashv \Gamma''}{\Gamma \vdash s_1 \Semi s_2 \dashv \Gamma'' }

  \ir{IfStmt}{\Gamma \vdash s_1 \dashv \Gamma' \\ \Gamma \vdash s_2 \dashv \Gamma'}{\Gamma \vdash \If e \Then s_1 \Else s_2 \dashv \Gamma'}

  \ir{CallStmt}{ }{\Gamma \vdash m(e_1, e_2, ...) \dashv \Gamma'}
\end{mathpar}
\jtodo{Return and method call}
\jc{IfStmt is very restrictive; we should check with Komi to see exactly what we want here, especially since classes will make things a lot more complicated. Likely we will need some unification over contexts here for the branches.}
